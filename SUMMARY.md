# 目录

* [引言](README.md)
    * 一个嵌入式操作系统的实现过程
    * 读者对象
    * 内容安排
    * 致谢

* [第一部分：构建内核](/Part1.md)
    * [1. 搭建工作环境：选择内核、处理器与工具链](/Chapter1.md)
        * [1.1. 认识嵌入式操作系统内核](/Chapter1.md#11-认识嵌入式操作系统内核)
            * [1.1.1. 操作系统是什么](/Chapter1.md#111-操作系统是什么)
            * [1.1.2. 嵌入式操作系统的特点](/Chapter1.md#112-嵌入式操作系统的特点)
            * [1.1.3. 内核要完成的工作](/Chapter1.md#113-内核要完成的工作)
            * [1.1.4. 内核的选择：微内核](/Chapter1.md#114-内核的选择：微内核)
        * [1.2. 选择硬件平台](/Chapter1.md#12-选择硬件平台)
            * [1.2.1. 计算机组成简介](/Chapter1.md#121-计算机组成简介)
            * [1.2.2. ARM Cortex-M4处理器与STM32微控制器](/Chapter1.md#122-arm-cortex-m4处理器与stm32微控制器)
            * [1.2.3. 探索者STM32F407开发板](/Chapter1.md#123-探索者stm32f407开发板)
        * [1.3. 搭建开发工具链](/Chapter1.md#13-搭建开发工具链)
            * [1.3.1. Linux系统环境及基本操作](/Chapter1.md#131-linux系统环境及基本操作)
            * [1.3.2. 文本编辑器：VS Code](/Chapter1.md#132-文本编辑器：vs-code)
            * [1.3.3. 交叉编译器：gcc-arm](/Chapter1.md#133-交叉编译器：gcc-arm)
            * [1.3.4. 代码烧录器：OpenOCD](/Chapter1.md#134-代码烧录器：openocd)
            * [1.3.5. 在线调试器：GDB](/Chapter1.md#135-在线调试器：gdb)
        * [1.4. 小结](/Chapter1.md#14-小结)

    * [2. 让处理器跑起来：编写boot引导程序](/Chapter2.md)
        * [2.1. 处理器的工作原理](/Chapter2.md#21-处理器的工作原理)
            * [2.1.1. ARM Cortex-M4的内核结构](/Chapter2.md#211-arm-cortex-m4的内核结构)
            * [2.1.2. ARM指令集与汇编语言简介](/Chapter2.md#212-arm指令集与汇编语言简介)
            * [2.1.3. STM32的上电过程](/Chapter2.md#213-stm32的上电过程)
        * [2.2. 编写引导程序](/Chapter2.md#22-编写引导程序)
            * [2.2.1. 用汇编实现的启动文件: boot.s](/Chapter2.md#221-用汇编实现的启动文件-boots)
            * [2.2.2. 从汇编程序跳转到C程序的main()函数](/Chapter2.md#222-从汇编程序跳转到c程序的main函数)
            * [2.2.3. 通过编译链接脚本生成二进制文件](/Chapter2.md#223-通过编译链接脚本生成二进制文件)
            * [2.2.4. 烧录并运行程序](/Chapter2.md#224-烧录并运行程序)
        * [2.3. 小结](/Chapter2.md#23-小结)

    * [3. 通过外设进行交互：编写串口驱动](/Chapter3.md)
        * [3.1. 外设驱动模型](/Chapter3.md#31-外设驱动模型)
            * [3.1.1. 外设类型](/Chapter3.md#311-外设类型)
            * [3.1.2. 外设驱动要完成的功能](/Chapter3.md#312-外设驱动要完成的功能)
            * [3.1.3. STM32片上外设的访问方法](/Chapter3.md#313-stm32片上外设的访问方法)
        * [3.2. 通过串口进行通信交互](/Chapter3.md#32-通过串口进行通信交互)
            * [3.2.1. 串口通信简介](/Chapter3.md#321-串口通信简介)
            * [3.2.2. 初始化串口](/Chapter3.md#322-初始化串口)
            * [3.2.3. 实现printf()](/Chapter3.md#323-实现printf)
            * [3.2.4. 轮询接收数据](/Chapter3.md#324-轮询接收数据)
        * [3.3. 小结](/Chapter3.md#33-小结)

    * [4. 及时处理突发事件：响应串口接收中断](/Chapter4.md)
        * [4.1. 处理器的中断机制](/Chapter4.md#41-处理器的中断机制)
            * [4.1.1. 什么是中断](/Chapter4.md#411-什么是中断)
            * [4.1.2. ARM Cortex-M4的中断控制器NVIC](/Chapter4.md#412-arm-cortex-m4的中断控制器nvic)
        * [4.2. 给串口驱动添加中断服务](/Chapter4.md#42-给串口驱动添加中断服务)
            * [4.2.1. 开启串口接收中断](/Chapter4.md#421-开启串口接收中断)
            * [4.2.2. 从中断向量表跳转到中断服务函数](/Chapter4.md#422-从中断向量表跳转到中断服务函数)
            * [4.2.3. 确认中断信号](/Chapter4.md#423-确认中断信号)
            * [4.2.4. 实现接收缓存队列](/Chapter4.md#424-实现接收缓存队列)
        * [4.3. 小结](/Chapter4.md#43-小结)

    * [5. 同时完成多项任务：CPU资源的时分复用](/Chapter5.md)
        * [5.1. 时分复用思想](/Chapter5.md#51-时分复用思想)
            * [5.1.1. 程序运行所需的资源](/Chapter5.md#511-程序运行所需的资源)
            * [5.1.2. 进程的前身：多道程序](/Chapter5.md#512-进程的前身：多道程序)
            * [5.1.3. 运行上下文切换原理](/Chapter5.md#513-运行上下文切换原理)
            * [5.1.4. ARM Cortex-M4针对上下文切换的优化](/Chapter5.md#514-arm-cortex-m4针对上下文切换的优化)
        * [5.2. 用汇编实现的上下文切换](/Chapter5.md#52-用汇编实现的上下文切换)
            * [5.2.1. 保存上文](/Chapter5.md#521-保存上文)
            * [5.2.2. 恢复下文](/Chapter5.md#522-恢复下文)
            * [5.2.3. 分配栈空间](/Chapter5.md#523-分配栈空间)
            * [5.2.4. 实现交替发送字符的两道程序](/Chapter5.md#524-实现交替发送字符的两道程序)
        * [5.3. 小结](/Chapter5.md#53-小结)

    * [6. 控制切换任务的节奏：引入系统时钟](/Chapter6.md)
        * [6.1. 时钟硬件](/Chapter6.md#61-时钟硬件)
            * [6.1.1. 处理器的主频](/Chapter6.md#611-处理器的主频)
            * [6.1.2. ARM Cortex-M4的内核计时器SysTick](/Chapter6.md#612-arm-cortex-m4的内核计时器systick)
        * [6.2. 定时触发上下文切换](/Chapter6.md#62-定时触发上下文切换)
            * [6.2.1. 初始化SysTick](/Chapter6.md#621-初始化systick)
            * [6.2.2. 开启计时器溢出中断](/Chapter6.md#622-开启计时器溢出中断)
            * [6.2.3. 在中断服务函数中触发上下文切换](/Chapter6.md#623-在中断服务函数中触发上下文切换)
        * [6.3. 小结](/Chapter6.md#63-小结)

    * [7.管理任务的运行状态：构建进程管理系统](/Chapter7.md)
        * [7.1. 进程管理组件](/Chapter7.md#71-进程管理组件)
            * [7.1.1. 进程描述符](/Chapter7.md#711-进程描述符)
            * [7.1.2. 进程的状态机](/Chapter7.md#712-进程的状态机)
            * [7.1.3. 进程队列](/Chapter7.md#713-进程队列)
        * [7.2. 实现第一个内核进程——init](/Chapter7.md#72-实现第一个内核进程——init)
            * [7.2.1. init进程的功能——空转](/Chapter7.md#721-init进程的功能——空转)
            * [7.2.2. 移植Linux内核的通用链表](/Chapter7.md#722-移植linux内核的通用链表)
            * [7.2.3. 初始化进程管理组件](/Chapter7.md#723-初始化进程管理组件)
        * [7.3. 实现第二个内核进程——echo](/Chapter7.md#73-实现第二个内核进程——echo)
            * [7.3.1. echo进程的功能——回显串口接收数据](/Chapter7.md#731-echo进程的功能——回显串口接收数据)
            * [7.3.2. echo进程主动挂起](/Chapter7.md#732-echo进程主动挂起)
            * [7.3.3. 在串口接收中断服务函数中唤醒进程](/Chapter7.md#733-在串口接收中断服务函数中唤醒进程)
        * [7.4. 小结](/Chapter7.md#74-小结)

    * [8.区别对待不同的任务：实现进程调度器](/Chapter8.md)
        * [8.1. 进程调度器](/Chapter8.md#81-进程调度器)
            * [8.1.1. 进程调度器的任务](/Chapter8.md#811-进程调度器的任务)
            * [8.1.2. 为进程划分时间片](/Chapter8.md#812-为进程划分时间片)
            * [8.1.3. 抢占式的优先调度](/Chapter8.md#813-抢占式的优先调度)
        * [8.2. 编写进程调度函数schedule()](/Chapter8.md#82-编写进程调度函数schedule)
            * [8.2.1. 调度函数schedule()的流程](/Chapter8.md#821-调度函数schedule的流程)
            * [8.2.2. 修改进程描述符](/Chapter8.md#822-修改进程描述符)
            * [8.2.3. 增加优先队列](/Chapter8.md#823-增加优先队列)
            * [8.2.4. 处理当前进程的时间片](/Chapter8.md#824-处理当前进程的时间片)
            * [8.2.5. 选择并切换进程](/Chapter8.md#825-选择并切换进程)
        * [8.3. 小结](/Chapter8.md#83-小结)

    * [9. 解除进程与外设的关联：用信号通知进程中断事件](/Chapter9.md)
        * [9.1. 中断、事件与信号](/Chapter9.md#91-中断、事件与信号)
            * [9.1.1. echo进程与串口中断服务的耦合关系](/Chapter9.md#911-echo进程与串口中断服务的耦合关系)
            * [9.1.2. 把中断抽象成事件](/Chapter9.md#912-把中断抽象成事件)
            * [9.1.3. 发布事件发生的信号](/Chapter9.md#913-发布事件发生的信号)
        * [9.2. 信号机制驱动的echo进程](/Chapter9.md#92-信号机制驱动的echo进程)
            * [9.2.1. 定义事件描述符](/Chapter9.md#921-定义事件描述符)
            * [9.2.2. 实现事件等待队列](/Chapter9.md#922-实现事件等待队列)
            * [9.2.3. 在进程中监听事件信号](/Chapter9.md#923-在进程中监听事件信号)
            * [9.2.4. 在中断中发布事件信号](/Chapter9.md#924-在中断中发布事件信号)
            * [9.2.5. 在调度时唤醒等待的进程](/Chapter9.md#925-在调度时唤醒等待的进程)
        * [9.3. 小结](/Chapter9.md#93-小结)

    * [10.建立进程之间的信息通道：IPC](/Chapter10.md)
        * [10.1. 进程间通信机制](/Chapter10.md#101-进程间通信机制)
            * [10.1.1. 异步IPC与同步IPC](/Chapter10.md#1011-异步ipc与同步ipc)
            * [10.1.2. 系统调用](/Chapter10.md#1012-系统调用)
            * [10.1.3. 建立在IPC上的微内核](/Chapter10.md#1013-建立在ipc上的微内核)
        * [10.2. 实现服务模式的同步IPC](/Chapter10.md#102-实现服务模式的同步ipc)
            * [10.2.1. 定义服务描述符](/Chapter10.md#1021-定义服务描述符)
            * [10.2.2. 实现系统调用msg\_send()](/Chapter10.md#1022-实现系统调用msgsend)
            * [10.2.3. 实现系统调用msg\_recv()](/Chapter10.md#1023-实现系统调用msgrecv)
            * [10.2.4. 提供系统时钟查询服务：tick进程](/Chapter10.md#1024-提供系统时钟查询服务：tick进程)
        * [10.3. 实现基于消息队列的异步IPC](/Chapter10.md#103-实现基于消息队列的异步ipc)
            * [10.3.1. 定义消息描述符](/Chapter10.md#1031-定义消息描述符)
            * [10.3.2. 把串口驱动封装成进程uart\_driver](/Chapter10.md#1032-把串口驱动封装成进程uartdriver)
            * [10.3.3. 注册进程uart\_driver的消息队列](/Chapter10.md#1033-注册进程uartdriver的消息队列)
            * [10.3.4. 异步调用msg\_send()发送消息](/Chapter10.md#1034-异步调用msgsend发送消息)
        * [10.4. 小结](/Chapter10.md#104-小结)

    * [11. 解决资源竞争的问题：给公共资源加锁](/Chapter11.md)
        * [11.1. 增加测试进程test——通过串口输出字符](/Chapter11.md#111-增加测试进程test——通过串口输出字符)
        * [11.2. test与echo的竞争关系](/Chapter11.md#112-test与echo的竞争关系)
            * [11.2.1. 竞争条件](/Chapter11.md#1121-竞争条件)
            * [11.2.2. 临界区](/Chapter11.md#1122-临界区)
        * [11.3. 实现互斥信号量mutex_t](/Chapter11.md#113-实现互斥信号量mutext)
            * [11.3.1. ARM Cortex-M4互斥访问方法](/Chapter11.md#1131-arm-cortex-m4互斥访问方法)
            * [11.3.2. 实现函数mutex_lock()与mutex_free()](/Chapter11.md#1132-实现函数mutexlock与mutexfree)
            * [11.3.3. 用mutex_t保护串口外设资源](/Chapter11.md#1133-用mutext保护串口外设资源)
        * [11.4. 小结](/Chapter11.md#114-小结)

    * [12. 发布内核V1.0](/Chapter12.md)
        * [12.1. 迟到的系统框图](/Chapter12.md#121-迟到的系统框图)
        * [12.2. 内核V1.0的适用场景](/Chapter12.md#122-内核v1.0的适用场景)
        * [12.3. 移植内核](/Chapter12.md#123-移植内核)
        * [12.4. 小结](/Chapter12.md#124-小结)

* [第二部分：丰富内核](/Part2.md)
    * [13. 扩展系统内存空间：突破片上内存的限制](/Chapter13.md)
        * [13.1. 计算机的内存系统](/Chapter13.md#131-计算机的内存系统)
            * [13.1.1. 计算机的层次化存储结构简介](/Chapter13.md#1311-计算机的层次化存储结构简介)
            * [13.1.2. ARM Cortex-M4的内存空间划分](/Chapter13.md#1312-arm-cortex-m4的内存空间划分)
            * [13.1.3. STM32的静态存储管理器FSMC](/Chapter13.md#1313-stm32的静态存储管理器fsmc)
            * [13.1.4. 开发板上的扩展内存SRAM](/Chapter13.md#1314-开发板上的扩展内存sram)
        * [13.2. 驱动扩展内存SRAM](/Chapter13.md#132-驱动扩展内存sram)
            * [13.2.1. 配置FSMC的时钟和相关引脚](/Chapter13.md#1321-配置fsmc的时钟和相关引脚)
            * [13.2.2. 设置FSMC的工作模式](/Chapter13.md#1322-设置fsmc的工作模式)
            * [13.2.3. 读写SRAM](/Chapter13.md#1323-读写sram)
        * [13.3. 小结](/Chapter13.md#133-小结)

    * [14. 支持动态分配内存：构建内存管理系统](/Chapter14.md)
        * [14.1. 进程的内存空间](/Chapter14.md#141-进程的内存空间)
            * [14.1.1. 栈空间](/Chapter14.md#1411-栈空间)
            * [14.1.2. 堆空间](/Chapter14.md#1412-堆空间)
            * [14.1.3. 静态数据空间](/Chapter14.md#1413-静态数据空间)
        * [14.2. 实现堆空间内存的动态分配](/Chapter14.md#142-实现堆空间内存的动态分配)
            * [14.2.1. 初始化内存池](/Chapter14.md#1421-初始化内存池)
            * [14.2.2. malloc()接口实现](/Chapter14.md#1422-malloc接口实现)
            * [14.2.3. free()接口实现 ](/Chapter14.md#1423-free接口实现 )
        * [14.3. 小结](/Chapter14.md#143-小结)

    * [15.防止用户篡改系统数据：保护内核的内存空间](/Chapter15.md)
        * [15.1. 操作系统内核的内存空间](/Chapter15.md#151-操作系统内核的内存空间)
            * [15.1.1. 内核态与用户态](/Chapter15.md#1511-内核态与用户态)
            * [15.1.2. ARM Cortex-M4的内存保护单元MPU](/Chapter15.md#1512-arm-cortex-m4的内存保护单元mpu)
            * [15.1.3. 高级内存管理单元MMU简介](/Chapter15.md#1513-高级内存管理单元mmu简介)
        * [15.2. 通过MPU保护内存空间](/Chapter15.md#152-通过mpu保护内存空间)
            * [15.2.1. 指定内核的内存空间](/Chapter15.md#1521-指定内核的内存空间)
            * [15.2.2. 在进程描述符中记录内存的使用情况](/Chapter15.md#1522-在进程描述符中记录内存的使用情况)
            * [15.2.3. 在进程切换时修改MPU的保护项](/Chapter15.md#1523-在进程切换时修改mpu的保护项)
        * [15.3. 小结](/Chapter15.md#153-小结)
    * [16.解决内存数据掉电丢失的问题：扩展外部存储空间](/Chapter16.md)
        * [16.1. 计算机的外部存储](/Chapter16.md#161-计算机的外部存储)
            * [16.1.1. 常见的外部存储介质](/Chapter16.md#1611-常见的外部存储介质)
            * [16.1.2. 开发板上的SD存储卡](/Chapter16.md#1612-开发板上的sd存储卡)
            * [16.1.3. STM32的SDIO接口](/Chapter16.md#1613-stm32的sdio接口)
        * [16.2. 实现SD卡驱动程序](/Chapter16.md#162-实现sd卡驱动程序)
            * [16.2.1. 初始化SDIO接口](/Chapter16.md#1621-初始化sdio接口)
            * [16.2.2. 完成SD卡的枚举过程](/Chapter16.md#1622-完成sd卡的枚举过程)
            * [16.2.3. 实现SD卡的读写操作](/Chapter16.md#1623-实现sd卡的读写操作)
        * [16.3. 实现SD卡驱动的专用进程](/Chapter16.md#163-实现sd卡驱动的专用进程)
            * [16.3.1. 定义驱动进程的服务和消息](/Chapter16.md#1631-定义驱动进程的服务和消息)
            * [16.3.2. 实现SD卡的驱动循环](/Chapter16.md#1632-实现sd卡的驱动循环)
        * [16.4. 小结](/Chapter16.md#164-小结)
    * [17. 管理外部存储空间：构建文件系统](/Chapter17.md)
        * [17.1. 文件系统简介](/Chapter17.md#171-文件系统简介)
            * [17.1.1. 文件系统的功能](/Chapter17.md#1711-文件系统的功能)
            * [17.1.2. 文件与目录](/Chapter17.md#1712-文件与目录)
            * [17.1.3. 常见的文件系统方案](/Chapter17.md#1713-常见的文件系统方案)
        * [17.2. 建立一个基于FAT表的文件系统](/Chapter17.md#172-建立一个基于fat表的文件系统)
            * [17.2.1. 设计文件的存放方式](/Chapter17.md#1721-设计文件的存放方式)
            * [17.2.2. FAT表的实现](/Chapter17.md#1722-fat表的实现)
            * [17.2.3. 抽象文件属性](/Chapter17.md#1723-抽象文件属性)
            * [17.2.4. 以文件形式存储的根目录](/Chapter17.md#1724-以文件形式存储的根目录)
            * [17.2.5. 格式化磁盘的接口](/Chapter17.md#1725-格式化磁盘的接口)
            * [17.2.6. 解析文件名](/Chapter17.md#1726-解析文件名)
        * [17.3. 小结](/Chapter17.md#173-小结)
    * [18. 外部存储中数据的增删改查：实现文件系统管理器](/Chapter18.md)
        * [18.1. 实现文件系统的基本操作](/Chapter18.md#181-实现文件系统的基本操作)
            * [18.1.1. 检查文件是否存在](/Chapter18.md#1811-检查文件是否存在)
            * [18.1.2. 创建文件](/Chapter18.md#1812-创建文件)
            * [18.1.3. 打开文件](/Chapter18.md#1813-打开文件)
            * [18.1.4. 读写文件](/Chapter18.md#1814-读写文件)
            * [18.1.5. 关闭文件](/Chapter18.md#1815-关闭文件)
            * [18.1.6. 删除文件](/Chapter18.md#1816-删除文件)
        * [18.2. 实现文件管理进程](/Chapter18.md#182-实现文件管理进程)
            * [18.2.1. 文件系统基本操作的服务](/Chapter18.md#1821-文件系统基本操作的服务)
            * [18.2.2. 实现管理进程的控制循环](/Chapter18.md#1822-实现管理进程的控制循环)
        * [18.3. 小结](/Chapter18.md#183-小结)
    * [19. 管理丰富多样的系统外设：建立统一的外设驱动框架](/Chapter19.md)
        * [19.1. 把外设抽象成文件](/Chapter19.md#191-把外设抽象成文件)
            * [19.1.1. 外设是一种特殊的文件](/Chapter19.md#1911-外设是一种特殊的文件)
            * [19.1.2. 定义文件操作符file\_operators](/Chapter19.md#1912-定义文件操作符fileoperators)
            * [19.1.3. 定义文件描述符file](/Chapter19.md#1913-定义文件描述符file)
            * [19.1.4. 定义已打开文件的描述符inode](/Chapter19.md#1914-定义已打开文件的描述符inode)
        * [19.2. 把串口抽象为字符设备](/Chapter19.md#192-把串口抽象为字符设备)
            * [19.2.1. 向内核注册串口驱动](/Chapter19.md#1921-向内核注册串口驱动)
            * [19.2.2. 通过open()获取串口资源](/Chapter19.md#1922-通过open获取串口资源)
            * [19.2.3. 通过close()释放串口资源](/Chapter19.md#1923-通过close释放串口资源)
            * [19.2.4. 实现字符设备的读写接口](/Chapter19.md#1924-实现字符设备的读写接口)
            * [19.2.5. 定义串口设备的配置接口ioctl()](/Chapter19.md#1925-定义串口设备的配置接口ioctl)
        * [19.3. 把SD卡抽象为块设备](/Chapter19.md#193-把sd卡抽象为块设备)
            * [19.3.1. 注册SD卡驱动](/Chapter19.md#1931-注册sd卡驱动)
            * [19.3.2. 实现获取和释放SD卡资源的接口](/Chapter19.md#1932-实现获取和释放sd卡资源的接口)
            * [19.3.3. 实现块设备的读写接口](/Chapter19.md#1933-实现块设备的读写接口)
            * [19.3.4. 实现配置接口ioctl()](/Chapter19.md#1934-实现配置接口ioctl)
        * [19.4. 小结](/Chapter19.md#194-小结)
    * [20. 发布内核V2.0](/Chapter20.md)
        * [20.1. 更新系统框图](/Chapter20.md#201-更新系统框图)
        * [20.2. 内核V2.0的适用场景](/Chapter20.md#202-内核V2.0的适用场景)
        * [20.3. 可能的探索方向](/Chapter20.md#203-可能的探索方向)
        * [20.4. 小结](/Chapter20.md#204-小结)
* [参考资料](/Reference.md)
* [测试页](/test.md)


